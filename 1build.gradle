// build.gradle 文件
// 建议运行在JDK1.8下，Gradle5.0将不再支持JDK1.7的运行
// Support for running Gradle using Java 7 has been deprecated and is scheduled to be removed in Gradle 5.0.

// 定义 helloword 任务
// 命令行终端执行 gradle -q helloword 输出 Hello world!
// 选项 -q 表示 --quiet
task helloword {
	// doLast 语句
	doLast {
		println 'Hello world!'
	}		
}

// 可以指定一个快捷键（<<符号表示）到 doLast 语句来简化 helloword 任务
// 但不建议这么使用，因为<<将在Gradle5.0中删除
// The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.
task hellowordLeftShift << {
	println 'Hello world!';
}

// Gradle 构建脚本使用 Groovy API
task upper {
	doLast {
		String expString = 'Yiibai gradle totorials'
		println "Original: " + expString
		println "Upper case: " + expString.toUpperCase()
	}
}

// 4次打印隐式参数（$it）的值
task count {
	doLast{
		4.times {
			print "$it"
		}
	}
}

// Groovy的JDK方法
// Groovy增加了很多有用的方法到标准的Java类。例如，从Java API可迭代实现它遍历Iterable接口的元素的 each() 方法。
task groovyJDKMethod {
	doLast {
		String myName = "Yiibai";
		myName.each(){
			println "${it}"
		};
	}
}

task hello

// 定位任务
// 如果要查找在构建文件中定义的任务，则必须使用相应的标准项目属性。这意味着每个任务都可以作为项目的属性，使用任务名称作为属性名称。
println tasks.hello.name
println tasks['hello'].name

// 任务依赖关系
task intro(dependsOn: 'helloword'){
	doLast{
		println "I'm gradle"
	}
}

task taskX(dependsOn: 'taskY'){
	doLast{
		println "taskX"
	}
}

task taskY{
	doLast{
		println 'taskY'
	}
}

// 另一种方法来添加任务依赖，它就是通过使用闭包。

task taskXLib {
	doLast{
		println 'taskXLib'
	}
}

taskXLib.dependsOn{
	tasks.findAll{
		task -> task.name.startsWith('lib')
	}
}

task lib1 {
	doLast{
		println 'lib1'
	}
}

task lib2 {
	doLast {
		println 'lib2'
	}
}

task notALib {
	doLast {
		println 'notALib' 
	}
}

// 向任务添加描述
// 使用 description 关键字可以向任务添加描述，执行Gradle任务时会显示此描述。
// 执行任务一个task都会显示，不只是copy
task copy(type: Copy){
	description 'Copies the resource directory to the target directory.'
	from 'resource'
	into 'target'
	include('**/*.txt', '**/*.xml', '**/*.properties')
	println('description applied')
}

// 跳过任务
// 如果用于跳过任务的逻辑不能用谓词表示，则可以使用 StopExecutionException 。如果操作抛出此异常，则会跨过此操作的进一步执行以及此任务的后续操作的执行。
task compile {
	doLast{
		println 'We are doing the compile.'
	}
}

compile.doFirst{
	// Here you would put arbitrary conditions in real life.
	// But this is used in an integration test so we want defined behavior.
	if(true){ throw new StopExecutionException() }
}

task myTask(dependsOn: 'compile'){
	doLast{
		println 'I am not affected'
	}
}

