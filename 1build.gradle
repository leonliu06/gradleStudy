// build.gradle 文件
// 建议运行在JDK1.8下，Gradle5.0将不再支持JDK1.7的运行
// Support for running Gradle using Java 7 has been deprecated and is scheduled to be removed in Gradle 5.0.

// 定义 helloword 任务
// 命令行终端执行 gradle -q helloword 输出 Hello world!
// 选项 -q 表示 --quiet
task helloword {
	// doLast 语句
	doLast {
		println 'Hello world!'
	}		
}

// 可以指定一个快捷键（<<符号表示）到 doLast 语句来简化 helloword 任务
// 但不建议这么使用，因为<<将在Gradle5.0中删除
// The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.
task hellowordLeftShift << {
	println 'Hello world!';
}

// Gradle 构建脚本使用 Groovy API
task upper {
	doLast {
		String expString = 'Yiibai gradle totorials'
		println "Original: " + expString
		println "Upper case: " + expString.toUpperCase()
	}
}

// 4次打印隐式参数（$it）的值
task count {
	doLast{
		4.times {
			print "$it"
		}
	}
}

// Groovy的JDK方法
// Groovy增加了很多有用的方法到标准的Java类。例如，从Java API可迭代实现它遍历Iterable接口的元素的 each() 方法。
task groovyJDKMethod {
	doLast {
		String myName = "Yiibai";
		myName.each(){
			println "${it}"
		};
	}
}

task hello

// 定位任务
// 如果要查找在构建文件中定义的任务，则必须使用相应的标准项目属性。这意味着每个任务都可以作为项目的属性，使用任务名称作为属性名称。
println tasks.hello.name
println tasks['hello'].name

// 任务依赖关系
task intro(dependsOn: 'helloword'){
	doLast{
		println "I'm gradle"
	}
}

task taskX(dependsOn: 'taskY'){
	doLast{
		println "taskX"
	}
}

task taskY{
	doLast{
		println 'taskY'
	}
}

task task1 << {
	println 'compiling source #1'
}

task task2(dependsOn: task1) << {
	println 'compiling unit tests #2'
}

task task3(dependsOn: [task1, task2]) << {
	println 'running unit tests #3'
}

task task4(dependsOn: [task1, task3]) << {
	println 'building the distribution #4'
}

// 另一种方法来添加任务依赖，它就是通过使用闭包。
task taskXLib {
	doLast{
		println 'taskXLib'
	}
}

taskXLib.dependsOn{
	tasks.findAll{
		task -> task.name.startsWith('lib')
	}
}

task lib1 {
	doLast{
		println 'lib1'
	}
}

task lib2 {
	doLast {
		println 'lib2'
	}
}

task notALib {
	doLast {
		println 'notALib' 
	}
}

// 向任务添加描述
// 使用 description 关键字可以向任务添加描述，执行Gradle任务时会显示此描述。
// 执行任务一个task都会显示，不只是copy
task copy(type: Copy){
	description 'Copies the resource directory to the target directory.'
	from 'resource'
	into 'target'
	include('**/*.txt', '**/*.xml', '**/*.properties')
	println('description applied')
}

// 跳过任务
// 如果用于跳过任务的逻辑不能用谓词表示，则可以使用 StopExecutionException 。如果操作抛出此异常，则会跨过此操作的进一步执行以及此任务的后续操作的执行。
task compile {
	doLast{
		println 'We are doing the compile.'
	}
}

compile.doFirst{
	// Here you would put arbitrary conditions in real life.
	// But this is used in an integration test so we want defined behavior.
	if(true){ throw new StopExecutionException() }
}

task myTask(dependsOn: 'compile'){
	doLast{
		println 'I am not affected'
	}
}

// 插件
/*
* Gradle中有两种类型的插件：脚本插件和二进制插件。
* 脚本插件是一个额外的构建脚本，它提供了一种声明性方法来操作构建，通常在构建中使用。
* 二进制插件是实现插件接口并采用编程方法来操作构建的类。二进制插件可以驻留在插件JAR中的一个构建脚本和项目层次结构或外部。
* */
apply plugin: 'java'

repositories{
	mavenCentral()
}

// 编写自定义插件
// 一个简单的hello插件
apply plugin: HelloPlugin

class HelloPlugin implements Plugin<Project> {
	void apply(Project project){
		project.task('hello') {
			doLast {
				println "Hello from the HelloPlugin."
			}
		}
	}
}

// 依赖
/*
* 声明依赖关系
* Gradle遵循一些特殊语法来定义依赖关系。
* 以下脚本定义了两个依赖项，一个是Hibernate core 3.6.7，第二个是Junit 4.0和更高版本。
* 如下面的代码所示，可在build.gradle文件中使用此代码。
* */
dependencies{
	compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'
	testCompile group: 'junit', name: 'junit', version: '4.+'
}
